package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/dullgiulio/pingo"

	//todo vendor this dependency
	nan "nanocloud.com/plugins/ldap/libnan"
)

type LDAPConfig struct {
	ScriptsDir string
	Username   string
	Password   string
	ServerURL  string
}

type AccountParams struct {
	UserEmail string
	Password  string
}

type Ldap struct{}

var (
	g_LDAPConfig LDAPConfig
)

func (p *Ldap) Configure(jsonConfig string, _outMsg *string) error {
	var ldapConfig map[string]string

	err := json.Unmarshal([]byte(jsonConfig), &ldapConfig)
	if err != nil {
		r := fmt.Sprintf("ERROR: failed to unmarshal LDAP Plugin configuration : %s", err.Error())
		log.Printf(r)
		os.Exit(0)
		*_outMsg = r
		return nil
	}

	g_LDAPConfig.ServerURL = ldapConfig["serverUrl"]
	g_LDAPConfig.Username = ldapConfig["username"]
	g_LDAPConfig.Password = ldapConfig["password"]
	g_LDAPConfig.ScriptsDir = ldapConfig["scriptsDir"]

	phpConfigFile, e := os.Create(filepath.Join(g_LDAPConfig.ScriptsDir, "configuration.php"))
	if e != nil {
		r := fmt.Sprintf("ERROR: failed to configure php scripts : %s", err.Error())
		log.Printf(r)
		os.Exit(0)
		*_outMsg = r
		return nil
	}

	phpConfigFile.Write([]byte("<?php\n# DO NOT EDIT THIS FILE\n# automatically generated\n\n"))
	phpConfigFile.Write([]byte(fmt.Sprintf("$ldap_server = \"%s\";\n", g_LDAPConfig.ServerURL)))
	phpConfigFile.Write([]byte(fmt.Sprintf("$ldap_user = \"%s\";\n", g_LDAPConfig.Username)))
	phpConfigFile.Write([]byte(fmt.Sprintf("$ldap_pass = \"%s\";\n", g_LDAPConfig.Password)))
	phpConfigFile.Write([]byte("?>\n"))
	phpConfigFile.Close()

	return nil
}

func (p *Ldap) ListUser(jsonParams string, _outMsg *string) error {
	log.Println("LDAP Plugin : ListUser")
	*_outMsg = "0" // return code meaning failure of operation

	cmd := exec.Command("/usr/bin/php", "list_LDAP_accounts.php")
	cmd.Dir = g_LDAPConfig.ScriptsDir

	out, err := cmd.Output()
	if err != nil {
		log.Printf("Failed to run script list_LDAP_accounts.php, error: %s, output: %s\n", err, string(out))
	} else {
		*_outMsg = string(out)
	}

	return nil
}

func (p *Ldap) AddUser(jsonParams string, _outMsg *string) error {
	*_outMsg = "0" // return code meaning failure of operation

	var params AccountParams

	if err := json.Unmarshal([]byte(jsonParams), &params); err != nil {
		r := nan.NewExitCode(0, "ERROR: failed to unmarshal Ldap.AccountParams : "+err.Error())
		log.Printf(r.Message) // for on-screen debug output
		*_outMsg = r.ToJson() // return codes for IPC should use JSON as much as possible
		return nil
	}

	cmd := exec.Command("/usr/bin/php", "add_LDAP_user.php", params.UserEmail, params.Password)
	cmd.Dir = g_LDAPConfig.ScriptsDir

	out, err := cmd.Output()
	if err != nil {
		fmt.Printf("Failed to run script add_LDAP_user.php for email <%s> and password <%s>, error: %s, output: %s\n",
			params.UserEmail, params.Password, err, string(out))
	} else {
		*_outMsg = string(out)

	}

	return nil
}

func (p *Ldap) ForceDisableAccount(jsonParams string, _outMsg *string) error {
	*_outMsg = "0" // return code meaning failure of operation

	var params AccountParams

	if err := json.Unmarshal([]byte(jsonParams), &params); err != nil {
		r := nan.NewExitCode(0, "ERROR: failed to unmarshal Ldap.AccountParams : "+err.Error())
		log.Printf(r.Message) // for on-screen debug output
		*_outMsg = r.ToJson() // return codes for IPC should use JSON as much as possible
		return nil
	}

	//fmt.Println("Running force disable for:", params.UserEmail)

	// TODO UserEmail is wrong here, use SAMACCOUNT (this piece of data is not stored yet)
	// Fred to OP: woot ?
	cmd := exec.Command("/usr/bin/php", "force_disable_LDAP_user.php", params.UserEmail)
	cmd.Dir = g_LDAPConfig.ScriptsDir

	out, err := cmd.Output()
	if err != nil {
		fmt.Printf("Failed to run script force_disable_LDAP_user.php for email <%s>, error: %s, output: %s\n",
			params.UserEmail, err, string(out))

	} else {
		// TODO this return code should be JSON'ified
		*_outMsg = "1" //success
	}

	// Log("LDAP Check... %s account(s) disabled", string(out))

	return nil
}

func (p *Ldap) DisableAccount(jsonParams string, _outMsg *string) error {
	*_outMsg = "0" // return code meaning failure of operation

	var params AccountParams

	if err := json.Unmarshal([]byte(jsonParams), &params); err != nil {
		r := nan.NewExitCode(0, "ERROR: failed to unmarshal Ldap.AccountParams : "+err.Error())
		log.Printf(r.Message)
		*_outMsg = r.ToJson() // return codes for IPC should use JSON as much as possible
		return nil
	}

	cmd := exec.Command("/usr/bin/php", "disable_LDAP_user.php", params.UserEmail)
	cmd.Dir = g_LDAPConfig.ScriptsDir

	out, err := cmd.Output()
	if err != nil {
		fmt.Printf("Failed to run script disable_LDAP_user.php for email <%s>, error: %s, output: %s\n",
			params.UserEmail, err, string(out))
	} else {
		// TODO this return code should be JSON'ified
		*_outMsg = "1" // success
	}

	return nil
}

func main() {

	plugin := &Ldap{}

	pingo.Register(plugin)

	pingo.Run()
}
